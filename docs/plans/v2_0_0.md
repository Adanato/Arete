# Arete v2.0.0 Implementation Plan
A structured plan to introduce a dependency-aware knowledge layer on top of the existing Obsidian â†” Anki workflow.

---

## Goals
1. **Schema upgrade** to support explicit graph structure:
   - `deps.requires` (hard prerequisites)
   - `deps.related` (soft/associative links)
2. **Editing UX** to make linking cards easy (no manual YAML wrangling):
   - link cards â†” cards
   - optionally link cards â†” concept nodes
3. **Local graph view** (like a scoped Obsidian Graph View) for visual debugging and navigation.
4. **Anki custom deck (filtered deck) creator** that produces dependency-aware study queues:
   - prerequisites first
   - strengthen weak prerequisites before dependents
   - keep Anki as the scheduling backend (FSRS stays untouched)

Non-goal (v2): global vault-scale graph visualization with Obsidian-level polish.

---

## Glossary
- **Arete card**: a single Anki card definition stored in YAML.
- **Arete ID**: stable identifier owned by Arete (never rely on Anki IDs for identity).
- **requires edge**: A â†’ B meaning â€œA requires B to be understood.â€
- **related edge**: A â†” B meaning â€œA is conceptually related to B (no ordering constraint).â€
- **closure**: all prerequisites for a target card (requires graph traversal).

---

## 1) Schema Design

### 1.1 Requirements
- Stable identity for each card independent of:
  - YAML ordering
  - text edits
  - Anki note id changes / exports
- Dependencies must reference **Arete IDs**, not Anki IDs.
- Must support both:
  - within-file links (cards in the same note)
  - cross-file links (cards anywhere in the vault)

### 1.2 Proposed v2 Schema (Card-centric)
```yaml
cards:
  - id: C_horizon_line_def
    model: Basic
    fields:
      Front: "What is the horizon line?"
      Back: "It represents the viewerâ€™s eye level."
    anki:
      nid: 1701234567890   # optional until exported
    deps:
      requires: [C_eye_level_def]
      related:  [C_vanishing_point_def]

  - id: C_eye_level_def
    model: Basic
    fields:
      Front: "What is eye level?"
      Back: "The height of the viewerâ€™s eyes; determines the horizon line."
```

**Notes**
- `id` is mandatory for every card.
- `anki.nid` remains optional and is treated as a mapping field.
- `fields` is the canonical place for model fields (avoids special YAML keys).

### 1.3 Optional: Concept Node (Future-friendly)
If later you want â€œconcept-levelâ€ grouping without exploding the graph:

```yaml
concept:
  id: N_perspective_basics
  deps:
    requires: [N_visual_angle]
    related:  [N_depth_cues]

cards:
  - id: C_horizon_line_def
    concept_id: N_perspective_basics
```

*v2 recommendation: implement concept nodes only if you need them for UX; otherwise keep v2 purely card-centric.*

### 1.4 Migration Plan (v1 â†’ v2)
**Input (v1-ish)**
```yaml
cards:
- model: Basic
  Front: ...
  Back: ...
  cid: ...
  nid: ...
```

**Migration steps**
For each card:
1.  generate `id` if missing
    -   preferred: slug-based (`C_${slug(front)}`) with collision suffix
    -   fallback: short hash (`C_${hash(front+back)[:6]}`)
2.  Move Front/Back/... under `fields`.
3.  Map `nid` into `anki.nid`.
4.  Deprecate `cid` at card level (or keep as alias temporarily).
5.  Write back updated YAML with stable ordering.

**Deliverables**
-   a migration command: `arete migrate schema-v2`
-   â€œdry runâ€ mode with a diff preview

---

## 2) Dependency Model

### 2.1 Semantics
-   `deps.requires`: ordering constraint. Used for prerequisite closure and study queue.
-   `deps.related`: non-ordering. Used for navigation, surfacing â€œsibling concepts,â€ and optional reinforcement decks.

### 2.2 Guardrails for Large Graphs
To avoid dependency explosion:
-   Max closure nodes (default): 200
-   Max depth (default): 6
-   Cycle detection:
    -   detect SCC/cycles during traversal
    -   surface warning and allow marking edges as `related` instead of `requires`

### 2.3 Dependency Health States (for gutter/UX)
-   ðŸ”— has prerequisites (requires non-empty)
-   âš ï¸ missing prereq (ID not found)
-   âš”ï¸ cycle detected (in closure)
-   ðŸ§± foundational (many dependents / high out-degree)
-   ðŸ§© overloaded (too many prereqs)

---

## 3) Editor UX (Linking + Dependency Editing)

### 3.1 Primary UX: â€œDependency Panelâ€ for Selected Card
A panel that appears when a card is selected in the YAML editor.

**Panel sections**
1.  **Card header**: title/preview, id, Anki link status
2.  **Requires**:
    -   list of prerequisite cards
    -   add/remove buttons
    -   reorder for tie-break priority (optional)
3.  **Related**:
    -   list of related cards
    -   add/remove
4.  **Diagnostics**:
    -   missing nodes, cycle warnings, closure size

### 3.2 Add-Link Flow
Search input with fuzzy match over:
-   card title heuristic (Front prefix)
-   note title
-   card id

**Results show**:
-   card preview
-   location (file / section)
-   maturity (if available)

Selecting inserts the Arete `id` into `requires` or `related`.

### 3.3 YAML Writing Rules (to keep diffs clean)
-   Always preserve stable key ordering.
-   Normalize arrays as single-line if short, multiline if long:
    -   `[A, B]` vs `- A`
-   Never rewrite fields unless content actually changed.

### 3.4 â€œLink Cards to Concepts and its Cardsâ€
If concept nodes exist:
-   concept selector (search)
-   show other cards under same concept for fast linking
If concept nodes do not exist (v2 card-centric):
-   â€œsame-note cardsâ€ list + â€œglobal searchâ€ provides similar benefit.

---

## 4) Local Graph View (Scoped)

### 4.1 Scope and Rendering
Scope: local neighborhood around the current card:
-   prerequisites (requires) up to depth N
-   dependents (reverse requires) up to depth N
-   related (optional toggle)

Node cap: default 150 (configurable)

### 4.2 Layout Strategy (v2 recommended)
Prefer a dependency-readable layout (DAG-ish) instead of force blob:
-   **Left column(s)**: prerequisites (distance increasing leftward)
-   **Center**: selected node
-   **Right column(s)**: dependents
-   **Dotted edges**: related

*Why: dependency graphs are about order, not â€œsimilarity clouds.â€*

### 4.3 Interactions
-   click node â†’ open note + scroll to card
-   hover node â†’ preview + quick stats + dependency summary
-   right-click edge â†’ convert requires â†” related
-   toggle:
    -   show related edges
    -   expand depth
    -   show only missing/cycle issues

### 4.4 Cycle UX
If a cycle exists:
-   highlight the cycle edges
-   offer quick fixes:
    -   convert one edge to related
    -   mark as â€œco-requisiteâ€ (optional future feature)

---

## 5) Dependency-Aware Anki Deck Creator (Study Queues)

### 5.1 Design Principle
-   Anki remains the scheduler (FSRS unchanged).
-   Arete creates temporary study queues that encourage prerequisite strengthening.

### 5.2 Primary Flow: â€œTodayâ€™s Dependency Queueâ€
1.  Fetch due targets from Anki (deck scope configurable).
2.  For each target card:
    -   resolve prerequisite closure via `requires`
3.  Identify **weak prerequisites**:
    -   not mature enough, recently lapsed, or never reviewed
4.  Create two filtered decks (or tag-based queues):
    -   **Arete â€“ Today: Prereqs**
    -   **Arete â€“ Today: Main**
5.  User studies prereqs first, then main.

### 5.3 â€œWeak prerequisiteâ€ heuristic (v2 baseline)
A prereq is considered weak if any:
-   lapses > 0 in last X reviews
-   stability below threshold
-   review_count < N
-   last_review too recent but still low stability
-   was edited in Obsidian since last sync (drift)

*(Keep thresholds configurable.)*

### 5.4 Ordering Strategy
Strict per-card ordering inside Anki is limited; instead:
1.  build staged queues by dependency levels:
    -   Level 1 (direct prereqs)
    -   Level 2 (prereqs of prereqs)
2.  enqueue weaker levels first

This provides dependency-respecting order without fighting Anki internals.

### 5.5 Failure Modes and UX
-   **Missing prereq**:
    -   warn, still create deck ignoring missing node
-   **Cycle**:
    -   treat cycle group as a bundle; include both in prereq deck
-   **Huge closure**:
    -   include only top K weakest prereqs and show summary

### 5.6 Deliverables
-   `arete queue today` CLI command
-   Obsidian button: â€œBuild Arete queueâ€
-   Results panel:
    -   how many prereqs added
    -   which were weak
    -   any missing/cycle issues

---

## 6) Data + Performance Strategy

### 6.1 Indexing
Maintain a cache/index:
`card_id â†’ {file, position, requires[], related[], anki_nid, preview}`

Rebuild on:
-   vault file changes
-   schema migration
-   explicit â€œreindexâ€ command

### 6.2 On-demand Traversal
Dependency resolution runs only when:
-   user opens dependency panel
-   user opens graph view
-   user builds a queue

### 6.3 Config
Add a config section:
-   max graph nodes
-   max depth
-   weak prereq thresholds
-   deck scopes / included Anki decks

---

## 7) Release Plan (v2.0.0 Milestones)

### Milestone 1: Schema + Migration (Must-have)
- [ ] Implement `id` per card (stable)
- [ ] Implement v1â†’v2 migration tool
- [ ] Basic validator (missing ids, malformed deps)

### Milestone 2: Dependency Editing (Must-have)
- [ ] Dependency panel
- [ ] Add/remove requires/related
- [ ] Health diagnostics (missing/cycle)
- [ ] Gutter indicator: has deps / missing / cycle

### Milestone 3: Local Graph (Should-have)
- [ ] Local graph view (2-hop default)
- [ ] Click-to-open navigation
- [ ] Toggle requires vs related

### Milestone 4: Anki Queue Builder (Must-have)
- [ ] Resolve due targets â†’ prereq closure
- [ ] Weak prereq selection
- [ ] Create filtered decks (or tag queue)
- [ ] Summary report to user

### Milestone 5: Polish + Docs (Should-have)
- [ ] Schema docs + examples
- [ ] â€œHow to model prerequisitesâ€ guide
- [ ] Common patterns + anti-patterns

---

## 8) Guidance for Users (Docs Snippets)

### When to use `requires`
Use `requires` only if:
-   the dependent card is genuinely confusing without the prerequisite

### When to use `related`
Use `related` when:
-   concepts reinforce each other
-   confusion happens between siblings
-   you want â€œstudy clusterâ€ benefits without strict order

### Anti-pattern: dependency spam
If a card requires 10+ prereqs:
-   itâ€™s likely overloaded
-   split it or promote a concept note and link to it

---

## 9) Success Metrics
-   Users can add prerequisites in <10 seconds per link.
-   Queue builder reduces â€œI donâ€™t understand this cardâ€ moments.
-   Dependency graph remains readable (local cap prevents hairballs).
-   Drift warnings prevent Anki training on outdated edits.
