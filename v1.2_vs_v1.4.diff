--- previous_ankiconnect.py	2026-01-16 18:17:04
+++ arete_ankiconnect/__init__.py	2026-01-16 18:12:24
@@ -13,6 +13,9 @@
 # You should have received a copy of the GNU General Public License
 # along with this program. If not, see <http://www.gnu.org/licenses/>.
 
+import sys
+
+# print(">>> ARETE ANKI CONNECT PLUGIN LOADING <<<", file=sys.stderr)
 import aqt
 
 anki_version = tuple(int(segment) for segment in aqt.appVersion.split("."))
@@ -37,21 +40,21 @@
 import anki.storage
 from anki.cards import Card
 from anki.consts import MODEL_CLOZE
+from anki.errors import NotFoundError
 from anki.exporting import AnkiPackageExporter
 from anki.importing import AnkiPackageImporter
 from anki.notes import Note
-from anki.errors import NotFoundError
-from aqt.qt import Qt, QTimer, QMessageBox, QCheckBox
+from aqt.qt import QCheckBox, QMessageBox, Qt, QTimer
 
-from .web import format_exception_reply, format_success_reply
+from . import util, web
 from .edit import Edit
-from . import web, util
+from .web import format_exception_reply, format_success_reply
 
-
 #
 # AnkiConnect
 #
 
+
 class AnkiConnect:
     def __init__(self):
         self.log = None
@@ -59,9 +62,9 @@
         self.server = web.WebServer(self.handler)
 
     def initLogging(self):
-        logPath = util.setting('apiLogPath')
+        logPath = util.setting("apiLogPath")
         if logPath is not None:
-            self.log = open(logPath, 'w')
+            self.log = open(logPath, "w")
 
     def startWebServer(self):
         try:
@@ -70,12 +73,14 @@
             # only keep reference to prevent garbage collection
             self.timer = QTimer()
             self.timer.timeout.connect(self.advance)
-            self.timer.start(util.setting('apiPollInterval'))
+            self.timer.start(util.setting("apiPollInterval"))
         except:
             QMessageBox.critical(
                 self.window(),
-                'AnkiConnect',
-                'Failed to listen on port {}.\nMake sure it is available and is not in use.'.format(util.setting('webBindPort'))
+                "AnkiConnect",
+                "Failed to listen on port {}.\nMake sure it is available and is not in use.".format(
+                    util.setting("webBindPort")
+                ),
             )
 
     def save_model(self, models, ankiModel):
@@ -83,27 +88,25 @@
 
     def logEvent(self, name, data):
         if self.log is not None:
-            self.log.write('[{}]\n'.format(name))
+            self.log.write(f"[{name}]\n")
             json.dump(data, self.log, indent=4, sort_keys=True)
-            self.log.write('\n\n')
+            self.log.write("\n\n")
             self.log.flush()
 
-
     def advance(self):
         self.server.advance()
 
-
     def handler(self, request):
-        self.logEvent('request', request)
+        self.logEvent("request", request)
 
-        name = request.get('action', '')
-        version = request.get('version', 4)
-        params = request.get('params', {})
-        key = request.get('key')
+        name = request.get("action", "")
+        version = request.get("version", 4)
+        params = request.get("params", {})
+        key = request.get("key")
 
         try:
-            if key != util.setting('apiKey') and name != 'requestPermission':
-                raise Exception('valid api key must be provided')
+            if key != util.setting("apiKey") and name != "requestPermission":
+                raise Exception("valid api key must be provided")
 
             method = None
 
@@ -111,8 +114,8 @@
                 apiVersionLast = 0
                 apiNameLast = None
 
-                if getattr(methodInst, 'api', False):
-                    for apiVersion, apiName in getattr(methodInst, 'versions', []):
+                if getattr(methodInst, "api", False):
+                    for apiVersion, apiName in getattr(methodInst, "versions", []):
                         if apiVersionLast < apiVersion <= version:
                             apiVersionLast = apiVersion
                             apiNameLast = apiName
@@ -125,7 +128,7 @@
                         break
 
             if method is None:
-                raise Exception('unsupported action')
+                raise Exception("unsupported action")
 
             api_return_value = methodInst(**params)
             reply = format_success_reply(version, api_return_value)
@@ -133,109 +136,96 @@
         except Exception as e:
             reply = format_exception_reply(version, e)
 
-        self.logEvent('reply', reply)
+        self.logEvent("reply", reply)
         return reply
 
-
     def window(self):
         return aqt.mw
 
-
     def reviewer(self):
         reviewer = self.window().reviewer
         if reviewer is None:
-            raise Exception('reviewer is not available')
+            raise Exception("reviewer is not available")
 
         return reviewer
 
-
     def collection(self):
         collection = self.window().col
         if collection is None:
-            raise Exception('collection is not available')
+            raise Exception("collection is not available")
 
         return collection
 
-
     def decks(self):
         decks = self.collection().decks
         if decks is None:
-            raise Exception('decks are not available')
+            raise Exception("decks are not available")
 
         return decks
 
-
     def scheduler(self):
         scheduler = self.collection().sched
         if scheduler is None:
-            raise Exception('scheduler is not available')
+            raise Exception("scheduler is not available")
 
         return scheduler
 
-
     def database(self):
         database = self.collection().db
         if database is None:
-            raise Exception('database is not available')
+            raise Exception("database is not available")
 
         return database
 
-
     def media(self):
         media = self.collection().media
         if media is None:
-            raise Exception('media is not available')
+            raise Exception("media is not available")
 
         return media
 
-
     def getModel(self, modelName):
         model = self.collection().models.byName(modelName)
         if model is None:
-            raise Exception('model was not found: {}'.format(modelName))
+            raise Exception(f"model was not found: {modelName}")
         return model
 
-
     def getField(self, model, fieldName):
         fieldMap = self.collection().models.fieldMap(model)
         if fieldName not in fieldMap:
-            raise Exception('field was not found in {}: {}'.format(model['name'], fieldName))
+            raise Exception("field was not found in {}: {}".format(model["name"], fieldName))
         return fieldMap[fieldName][1]
 
-
     def getTemplate(self, model, templateName):
-        for ankiTemplate in model['tmpls']:
-            if ankiTemplate['name'] == templateName:
+        for ankiTemplate in model["tmpls"]:
+            if ankiTemplate["name"] == templateName:
                 return ankiTemplate
-        raise Exception('template was not found in {}: {}'.format(model['name'], templateName))
+        raise Exception("template was not found in {}: {}".format(model["name"], templateName))
 
-
     def startEditing(self):
         self.window().requireReset()
 
-
     def stopEditing(self):
         if self.collection() is not None:
             self.window().maybeReset()
 
-
     def createNote(self, note):
         collection = self.collection()
 
-        model = collection.models.byName(note['modelName'])
+        model = collection.models.byName(note["modelName"])
         if model is None:
-            raise Exception('model was not found: {}'.format(note['modelName']))
+            raise Exception("model was not found: {}".format(note["modelName"]))
 
-        deck = collection.decks.byName(note['deckName'])
+        deck = collection.decks.byName(note["deckName"])
         if deck is None:
-            raise Exception('deck was not found: {}'.format(note['deckName']))
+            raise Exception("deck was not found: {}".format(note["deckName"]))
 
         ankiNote = anki.notes.Note(collection, model)
-        ankiNote.model()['did'] = deck['id']
-        if 'tags' in note:
-            ankiNote.tags = note['tags']
+        ankiNote.model()["did"] = deck["id"]
+        if "tags" in note:
+            ankiNote.tags = note["tags"]
 
-        for name, value in note['fields'].items():
+        for name, value in note["fields"].items():
             for ankiName in ankiNote.keys():
                 if name.lower() == ankiName.lower():
                     ankiNote[ankiName] = value
@@ -249,26 +239,30 @@
         duplicateScopeCheckChildren = False
         duplicateScopeCheckAllModels = False
 
-        if 'options' in note:
-            options = note['options']
-            if 'allowDuplicate' in options:
-                allowDuplicate = options['allowDuplicate']
+        if "options" in note:
+            options = note["options"]
+            if "allowDuplicate" in options:
+                allowDuplicate = options["allowDuplicate"]
                 if type(allowDuplicate) is not bool:
                     raise Exception('option parameter "allowDuplicate" must be boolean')
-            if 'duplicateScope' in options:
-                duplicateScope = options['duplicateScope']
-            if 'duplicateScopeOptions' in options:
-                duplicateScopeOptions = options['duplicateScopeOptions']
-                if 'deckName' in duplicateScopeOptions:
-                    duplicateScopeDeckName = duplicateScopeOptions['deckName']
-                if 'checkChildren' in duplicateScopeOptions:
-                    duplicateScopeCheckChildren = duplicateScopeOptions['checkChildren']
-                    if type(duplicateScopeCheckChildren) is not bool:
-                        raise Exception('option parameter "duplicateScopeOptions.checkChildren" must be boolean')
-                if 'checkAllModels' in duplicateScopeOptions:
-                    duplicateScopeCheckAllModels = duplicateScopeOptions['checkAllModels']
+            if "duplicateScope" in options:
+                duplicateScope = options["duplicateScope"]
+            if "duplicateScopeOptions" in options:
+                duplicateScopeOptions = options["duplicateScopeOptions"]
+                if "deckName" in duplicateScopeOptions:
+                    duplicateScopeDeckName = duplicateScopeOptions["deckName"]
+                if "checkChildren" in duplicateScopeOptions:
+                    duplicateScopeCheckChildren = duplicateScopeOptions["checkChildren"]
+                    if type(duplicateScopeCheckChildren) is not bool:
+                        raise Exception(
+                            'option parameter "duplicateScopeOptions.checkChildren" must be boolean'
+                        )
+                if "checkAllModels" in duplicateScopeOptions:
+                    duplicateScopeCheckAllModels = duplicateScopeOptions["checkAllModels"]
                     if type(duplicateScopeCheckAllModels) is not bool:
-                        raise Exception('option parameter "duplicateScopeOptions.checkAllModels" must be boolean')
+                        raise Exception(
+                            'option parameter "duplicateScopeOptions.checkAllModels" must be boolean'
+                        )
 
         duplicateOrEmpty = self.isNoteDuplicateOrEmptyInScope(
             ankiNote,
@@ -277,21 +271,20 @@
             duplicateScope,
             duplicateScopeDeckName,
             duplicateScopeCheckChildren,
-            duplicateScopeCheckAllModels
+            duplicateScopeCheckAllModels,
         )
 
         if duplicateOrEmpty == 1:
-            raise Exception('cannot create note because it is empty')
+            raise Exception("cannot create note because it is empty")
         elif duplicateOrEmpty == 2:
             if allowDuplicate:
                 return ankiNote
-            raise Exception('cannot create note because it is a duplicate')
+            raise Exception("cannot create note because it is a duplicate")
         elif duplicateOrEmpty == 0:
             return ankiNote
         else:
-            raise Exception('cannot create note for unknown reason')
+            raise Exception("cannot create note for unknown reason")
 
-
     def isNoteDuplicateOrEmptyInScope(
         self,
         note,
@@ -300,14 +293,14 @@
         duplicateScope,
         duplicateScopeDeckName,
         duplicateScopeCheckChildren,
-        duplicateScopeCheckAllModels
+        duplicateScopeCheckAllModels,
     ):
         # Returns: 1 if first is empty, 2 if first is a duplicate, 0 otherwise.
 
         # note.dupeOrEmpty returns if a note is a global duplicate with the specific model.
         # This is used as the default check, and the rest of this function is manually
         # checking if the note is a duplicate with additional options.
-        if duplicateScope != 'deck' and not duplicateScopeCheckAllModels:
+        if duplicateScope != "deck" and not duplicateScopeCheckAllModels:
             return note.dupeOrEmpty() or 0
 
         # Primary field for uniqueness
@@ -318,14 +311,14 @@
 
         # Create dictionary of deck ids
         dids = None
-        if duplicateScope == 'deck':
-            did = deck['id']
+        if duplicateScope == "deck":
+            did = deck["id"]
             if duplicateScopeDeckName is not None:
                 deck2 = collection.decks.byName(duplicateScopeDeckName)
                 if deck2 is None:
                     # Invalid deck, so cannot be duplicate
                     return 0
-                did = deck2['id']
+                did = deck2["id"]
 
             dids = {did: True}
             if duplicateScopeCheckChildren:
@@ -333,13 +326,13 @@
                     dids[kv[1]] = True
 
         # Build query
-        query = 'select id from notes where csum=?'
+        query = "select id from notes where csum=?"
         queryArgs = [csum]
         if note.id:
-            query += ' and id!=?'
+            query += " and id!=?"
             queryArgs.append(note.id)
         if not duplicateScopeCheckAllModels:
-            query += ' and mid=?'
+            query += " and mid=?"
             queryArgs.append(note.mid)
 
         # Search
@@ -348,7 +341,7 @@
                 # Duplicate note exists in the collection
                 return 2
             # Validate that a card exists in one of the specified decks
-            for cardDeckId in note.col.db.list('select did from cards where nid=?', noteId):
+            for cardDeckId in note.col.db.list("select did from cards where nid=?", noteId):
                 if cardDeckId in dids:
                     return 2
 
@@ -364,23 +357,25 @@
         try:
             return self.collection().getCard(card_id)
         except NotFoundError:
-            self.raiseNotFoundError('Card was not found: {}'.format(card_id))
+            self.raiseNotFoundError(f"Card was not found: {card_id}")
 
     def getNote(self, note_id: int) -> Note:
         try:
             return self.collection().getNote(note_id)
         except NotFoundError:
-            self.raiseNotFoundError('Note was not found: {}'.format(note_id))
+            self.raiseNotFoundError(f"Note was not found: {note_id}")
 
     def deckStatsToJson(self, due_tree):
-        deckStats = {'deck_id': due_tree.deck_id,
-                     'name': due_tree.name,
-                     'new_count': due_tree.new_count,
-                     'learn_count': due_tree.learn_count,
-                     'review_count': due_tree.review_count}
+        deckStats = {
+            "deck_id": due_tree.deck_id,
+            "name": due_tree.name,
+            "new_count": due_tree.new_count,
+            "learn_count": due_tree.learn_count,
+            "review_count": due_tree.review_count,
+        }
         if anki_version > (2, 1, 46):
             # total_in_deck is not supported on lower Anki versions
-            deckStats['total_in_deck'] = due_tree.total_in_deck
+            deckStats["total_in_deck"] = due_tree.total_in_deck
         return deckStats
 
     def collectDeckTreeChildren(self, parent_node):
@@ -396,53 +391,56 @@
 
     @util.api()
     def version(self):
-        return util.setting('apiVersion')
+        return util.setting("apiVersion")
 
-
     @util.api()
     def requestPermission(self, origin, allowed):
         results = {
-                "permission": "denied",
+            "permission": "denied",
         }
 
         if allowed:
             results = {
-                    "permission": "granted",
-                    "requireApikey": bool(util.setting('apiKey')),
-                    "version": util.setting('apiVersion')
+                "permission": "granted",
+                "requireApikey": bool(util.setting("apiKey")),
+                "version": util.setting("apiVersion"),
             }
 
-        elif origin in util.setting('ignoreOriginList'):
+        elif origin in util.setting("ignoreOriginList"):
             pass  # defaults to denied
 
         else:  # prompt the user
             msg = QMessageBox(None)
             msg.setWindowTitle("A website wants to access to Anki")
-            msg.setText('"{}" requests permission to use Anki through AnkiConnect. Do you want to give it access?'.format(origin))
-            msg.setInformativeText("By granting permission, you'll allow the website to modify your collection on your behalf, including the execution of destructive actions such as deck deletion.")
+            msg.setText(
+                f'"{origin}" requests permission to use Anki through AnkiConnect. Do you want to give it access?'
+            )
+            msg.setInformativeText(
+                "By granting permission, you'll allow the website to modify your collection on your behalf, including the execution of destructive actions such as deck deletion."
+            )
             msg.setWindowIcon(self.window().windowIcon())
             msg.setIcon(QMessageBox.Question)
-            msg.setStandardButtons(QMessageBox.Yes|QMessageBox.No)
+            msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
             msg.setDefaultButton(QMessageBox.No)
-            msg.setCheckBox(QCheckBox(text='Ignore further requests from "{}"'.format(origin), parent=msg))
+            msg.setCheckBox(QCheckBox(text=f'Ignore further requests from "{origin}"', parent=msg))
             msg.setWindowFlags(Qt.WindowStaysOnTopHint)
             pressedButton = msg.exec_()
 
             if pressedButton == QMessageBox.Yes:
                 config = aqt.mw.addonManager.getConfig(__name__)
-                config["webCorsOriginList"] = util.setting('webCorsOriginList')
+                config["webCorsOriginList"] = util.setting("webCorsOriginList")
                 config["webCorsOriginList"].append(origin)
                 aqt.mw.addonManager.writeConfig(__name__, config)
                 results = {
                     "permission": "granted",
-                    "requireApikey": bool(util.setting('apiKey')),
-                    "version": util.setting('apiVersion')
+                    "requireApikey": bool(util.setting("apiKey")),
+                    "version": util.setting("apiVersion"),
                 }
 
             # if the origin isn't an empty string, the user clicks "No", and the ignore box is checked
             elif origin and pressedButton == QMessageBox.No and msg.checkBox().isChecked():
                 config = aqt.mw.addonManager.getConfig(__name__)
-                config["ignoreOriginList"] = util.setting('ignoreOriginList')
+                config["ignoreOriginList"] = util.setting("ignoreOriginList")
                 config["ignoreOriginList"].append(origin)
                 aqt.mw.addonManager.writeConfig(__name__, config)
 
@@ -450,12 +448,10 @@
 
         return results
 
-
     @util.api()
     def getProfiles(self):
         return self.window().pm.profiles()
 
-
     @util.api()
     def loadProfile(self, name):
         if name not in self.window().pm.profiles():
@@ -483,34 +479,33 @@
 
         return True
 
-
     @util.api()
     def sync(self):
         self.window().onSync()
 
-
     @util.api()
     def multi(self, actions):
         return list(map(self.handler, actions))
 
-
     @util.api()
     def getNumCardsReviewedToday(self):
-        return self.database().scalar('select count() from revlog where id > ?', (self.scheduler().dayCutoff - 86400) * 1000)
+        return self.database().scalar(
+            "select count() from revlog where id > ?", (self.scheduler().dayCutoff - 86400) * 1000
+        )
 
     @util.api()
     def getNumCardsReviewedByDay(self):
-        return self.database().all('select date(id/1000 - ?, "unixepoch", "localtime") as day, count() from revlog group by day order by day desc',
-                                    int(time.strftime("%H", time.localtime(self.scheduler().dayCutoff))) * 3600)
+        return self.database().all(
+            'select date(id/1000 - ?, "unixepoch", "localtime") as day, count() from revlog group by day order by day desc',
+            int(time.strftime("%H", time.localtime(self.scheduler().dayCutoff))) * 3600,
+        )
 
-
     @util.api()
     def getCollectionStatsHTML(self, wholeCollection=True):
         stats = self.collection().stats()
         stats.wholeCollection = wholeCollection
         return stats.report()
 
-
     #
     # Decks
     #
@@ -519,7 +514,6 @@
     def deckNames(self):
         return self.decks().allNames()
 
-
     @util.api()
     def deckNamesAndIds(self):
         decks = {}
@@ -528,13 +522,12 @@
 
         return decks
 
-
     @util.api()
     def getDecks(self, cards):
         decks = {}
         for card in cards:
-            did = self.database().scalar('select did from cards where id=?', card)
-            deck = self.decks().get(did)['name']
+            did = self.database().scalar("select did from cards where id=?", card)
+            deck = self.decks().get(did)["name"]
             if deck in decks:
                 decks[deck].append(card)
             else:
@@ -542,7 +535,6 @@
 
         return decks
 
-
     @util.api()
     def createDeck(self, deck):
         try:
@@ -553,7 +545,6 @@
 
         return did
 
-
     @util.api()
     def changeDeck(self, cards, deck):
         self.startEditing()
@@ -568,10 +559,11 @@
         self.collection().sched.remFromDyn(cards)
 
         # then move into new deck
-        self.collection().db.execute('update cards set usn=?, mod=?, did=? where id in ' + scids, usn, mod, did)
+        self.collection().db.execute(
+            "update cards set usn=?, mod=?, did=? where id in " + scids, usn, mod, did
+        )
         self.stopEditing()
 
-
     @util.api()
     def deleteDecks(self, decks, cardsToo=False):
         if not cardsToo:
@@ -581,8 +573,9 @@
             # however, since 62c23c6816adf912776b9378c008a52bb50b2e8d (2.1.45)
             # passing cardsToo to `rem` (long deprecated) won't raise an error!
             # this is dangerous, so let's raise our own exception
-            raise Exception("Since Anki 2.1.28 it's not possible "
-                            "to delete decks without deleting cards as well")
+            raise Exception(
+                "Since Anki 2.1.28 it's not possible to delete decks without deleting cards as well"
+            )
         try:
             self.startEditing()
             decks = filter(lambda d: d in self.deckNames(), decks)
@@ -592,7 +585,6 @@
         finally:
             self.stopEditing()
 
-
     @util.api()
     def getDeckConfig(self, deck):
         if deck not in self.deckNames():
@@ -601,16 +593,15 @@
         collection = self.collection()
         did = collection.decks.id(deck)
         return collection.decks.confForDid(did)
-
 
     @util.api()
     def saveDeckConfig(self, config):
         collection = self.collection()
 
-        config['id'] = str(config['id'])
-        config['mod'] = anki.utils.intTime()
-        config['usn'] = collection.usn()
-        if int(config['id']) not in [c['id'] for c in collection.decks.all_config()]:
+        config["id"] = str(config["id"])
+        config["mod"] = anki.utils.intTime()
+        config["usn"] = collection.usn()
+        if int(config["id"]) not in [c["id"] for c in collection.decks.all_config()]:
             return False
         try:
             collection.decks.save(config)
@@ -619,12 +610,11 @@
             return False
         return True
 
-
     @util.api()
     def setDeckConfigId(self, decks, configId):
         configId = int(configId)
         for deck in decks:
-            if not deck in self.deckNames():
+            if deck not in self.deckNames():
                 return False
 
         collection = self.collection()
@@ -633,29 +623,27 @@
             try:
                 did = str(collection.decks.id(deck))
                 deck_dict = aqt.mw.col.decks.decks[did]
-                deck_dict['conf'] = configId
+                deck_dict["conf"] = configId
                 collection.decks.save(deck_dict)
             except:
                 return False
 
         return True
 
-
     @util.api()
-    def cloneDeckConfigId(self, name, cloneFrom='1'):
+    def cloneDeckConfigId(self, name, cloneFrom="1"):
         configId = int(cloneFrom)
         collection = self.collection()
-        if configId not in [c['id'] for c in collection.decks.all_config()]:
+        if configId not in [c["id"] for c in collection.decks.all_config()]:
             return False
 
         config = collection.decks.getConf(configId)
         return collection.decks.confId(name, config)
 
-
     @util.api()
     def removeDeckConfigId(self, configId):
         collection = self.collection()
-        if int(configId) not in [c['id'] for c in collection.decks.all_config()]:
+        if int(configId) not in [c["id"] for c in collection.decks.all_config()]:
             return False
 
         collection.decks.remConf(configId)
@@ -666,7 +654,7 @@
         collection = self.collection()
         scheduler = self.scheduler()
         responseDict = {}
-        deckIds = list(map(lambda d: collection.decks.id(d), decks))
+        deckIds = [collection.decks.id(d) for d in decks]
 
         allDeckNodes = self.collectDeckTreeChildren(scheduler.deck_due_tree())
         for deckId, deckNode in allDeckNodes.items():
@@ -675,13 +663,15 @@
         return responseDict
 
     @util.api()
-    def storeMediaFile(self, filename, data=None, path=None, url=None, skipHash=None, deleteExisting=True):
+    def storeMediaFile(
+        self, filename, data=None, path=None, url=None, skipHash=None, deleteExisting=True
+    ):
         if not (data or path or url):
             raise Exception('You must provide a "data", "path", or "url" field.')
         if data:
             mediaData = base64.b64decode(data)
         elif path:
-            with open(path, 'rb') as f:
+            with open(path, "rb") as f:
                 mediaData = f.read()
         elif url:
             mediaData = util.download(url)
@@ -699,27 +689,24 @@
             self.deleteMediaFile(filename)
         return self.media().writeData(filename, mediaData)
 
-
     @util.api()
     def retrieveMediaFile(self, filename):
         filename = os.path.basename(filename)
-        filename = unicodedata.normalize('NFC', filename)
+        filename = unicodedata.normalize("NFC", filename)
         filename = self.media().stripIllegal(filename)
 
         path = os.path.join(self.media().dir(), filename)
         if os.path.exists(path):
-            with open(path, 'rb') as file:
-                return base64.b64encode(file.read()).decode('ascii')
+            with open(path, "rb") as file:
+                return base64.b64encode(file.read()).decode("ascii")
 
         return False
 
-
     @util.api()
-    def getMediaFilesNames(self, pattern='*'):
+    def getMediaFilesNames(self, pattern="*"):
         path = os.path.join(self.media().dir(), pattern)
         return [os.path.basename(p) for p in glob.glob(path)]
 
-
     @util.api()
     def deleteMediaFile(self, filename):
         try:
@@ -739,25 +726,24 @@
         self.startEditing()
         nCardsAdded = collection.addNote(ankiNote)
         if nCardsAdded < 1:
-            raise Exception('The field values you have provided would make an empty question on all cards.')
+            raise Exception(
+                "The field values you have provided would make an empty question on all cards."
+            )
         collection.autosave()
         self.stopEditing()
 
         return ankiNote.id
 
-
     def addMediaFromNote(self, ankiNote, note):
-        audioObjectOrList = note.get('audio')
+        audioObjectOrList = note.get("audio")
         self.addMedia(ankiNote, audioObjectOrList, util.MediaType.Audio)
 
-        videoObjectOrList = note.get('video')
+        videoObjectOrList = note.get("video")
         self.addMedia(ankiNote, videoObjectOrList, util.MediaType.Video)
 
-        pictureObjectOrList = note.get('picture')
+        pictureObjectOrList = note.get("picture")
         self.addMedia(ankiNote, pictureObjectOrList, util.MediaType.Picture)
 
-
-
     def addMedia(self, ankiNote, mediaObjectOrList, mediaType):
         if mediaObjectOrList is None:
             return
@@ -768,30 +754,36 @@
             mediaList = [mediaObjectOrList]
 
         for media in mediaList:
-            if media is not None and len(media['fields']) > 0:
+            if media is not None and len(media["fields"]) > 0:
                 try:
-                    mediaFilename = self.storeMediaFile(media['filename'],
-                                                        data=media.get('data'),
-                                                        path=media.get('path'),
-                                                        url=media.get('url'),
-                                                        skipHash=media.get('skipHash'),
-                                                        deleteExisting=media.get('deleteExisting'))
+                    mediaFilename = self.storeMediaFile(
+                        media["filename"],
+                        data=media.get("data"),
+                        path=media.get("path"),
+                        url=media.get("url"),
+                        skipHash=media.get("skipHash"),
+                        deleteExisting=media.get("deleteExisting"),
+                    )
 
                     if mediaFilename is not None:
-                        for field in media['fields']:
+                        for field in media["fields"]:
                             if field in ankiNote:
                                 if mediaType is util.MediaType.Picture:
-                                    ankiNote[field] += u'<img src="{}">'.format(mediaFilename)
-                                elif mediaType is util.MediaType.Audio or mediaType is util.MediaType.Video:
-                                    ankiNote[field] += u'[sound:{}]'.format(mediaFilename)
+                                    ankiNote[field] += f'<img src="{mediaFilename}">'
+                                elif (
+                                    mediaType is util.MediaType.Audio
+                                    or mediaType is util.MediaType.Video
+                                ):
+                                    ankiNote[field] += f"[sound:{mediaFilename}]"
 
                 except Exception as e:
-                    errorMessage = str(e).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
-                    for field in media['fields']:
+                    errorMessage = (
+                        str(e).replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
+                    )
+                    for field in media["fields"]:
                         if field in ankiNote:
                             ankiNote[field] += errorMessage
 
-
     @util.api()
     def canAddNote(self, note):
         try:
@@ -799,23 +791,22 @@
         except:
             return False
 
-
     @util.api()
     def updateNoteFields(self, note):
-        ankiNote = self.getNote(note['id'])
+        ankiNote = self.getNote(note["id"])
 
         self.startEditing()
-        for name, value in note['fields'].items():
+        for name, value in note["fields"].items():
             if name in ankiNote:
                 ankiNote[name] = value
 
-        audioObjectOrList = note.get('audio')
+        audioObjectOrList = note.get("audio")
         self.addMedia(ankiNote, audioObjectOrList, util.MediaType.Audio)
 
-        videoObjectOrList = note.get('video')
+        videoObjectOrList = note.get("video")
         self.addMedia(ankiNote, videoObjectOrList, util.MediaType.Video)
 
-        pictureObjectOrList = note.get('picture')
+        pictureObjectOrList = note.get("picture")
         self.addMedia(ankiNote, pictureObjectOrList, util.MediaType.Picture)
 
         ankiNote.flush()
@@ -823,60 +814,52 @@
         self.collection().autosave()
         self.stopEditing()
 
-
     @util.api()
     def updateNote(self, note):
         updated = False
-        if 'fields' in note.keys():
+        if "fields" in note.keys():
             self.updateNoteFields(note)
             updated = True
-        if 'tags' in note.keys():
-            self.updateNoteTags(note['id'], note['tags'])
+        if "tags" in note.keys():
+            self.updateNoteTags(note["id"], note["tags"])
             updated = True
         if not updated:
             raise Exception('Must provide a "fields" or "tags" property.')
 
-
     @util.api()
     def updateNoteTags(self, note, tags):
         if type(tags) == str:
             tags = [tags]
-        if type(tags) != list or not all([type(t) == str for t in tags]):
-            raise Exception('Must provide tags as a list of strings')
+        if type(tags) != list or not all(type(t) == str for t in tags):
+            raise Exception("Must provide tags as a list of strings")
 
         for old_tag in self.getNoteTags(note):
             self.removeTags([note], old_tag)
         for new_tag in tags:
             self.addTags([note], new_tag)
 
-
     @util.api()
     def getNoteTags(self, note):
         return self.getNote(note).tags
 
-
     @util.api()
     def addTags(self, notes, tags, add=True):
         self.startEditing()
         self.collection().tags.bulkAdd(notes, tags, add)
         self.stopEditing()
 
-
     @util.api()
     def removeTags(self, notes, tags):
         return self.addTags(notes, tags, False)
 
-
     @util.api()
     def getTags(self):
         return self.collection().tags.all()
 
-
     @util.api()
     def clearUnusedTags(self):
         self.collection().tags.registerNotes()
 
-
     @util.api()
     def replaceTags(self, notes, tag_to_replace, replace_with_tag):
         self.window().progress.start()
@@ -896,13 +879,12 @@
         self.window().progress.finish()
         self.window().reset()
 
-
     @util.api()
     def replaceTagsInAllNotes(self, tag_to_replace, replace_with_tag):
         self.window().progress.start()
 
         collection = self.collection()
-        for nid in collection.db.list('select id from notes'):
+        for nid in collection.db.list("select id from notes"):
             note = self.getNote(nid)
             if note.hasTag(tag_to_replace):
                 note.delTag(tag_to_replace)
@@ -913,7 +895,6 @@
         self.window().progress.finish()
         self.window().reset()
 
-
     @util.api()
     def setEaseFactors(self, cards, easeFactors):
         couldSetEaseFactors = []
@@ -931,8 +912,7 @@
         return couldSetEaseFactors
 
     @util.api()
-    def setSpecificValueOfCard(self, card, keys,
-                               newValues, warning_check=False):
+    def setSpecificValueOfCard(self, card, keys, newValues, warning_check=False):
         if isinstance(card, list):
             print("card has to be int, not list")
             return False
@@ -946,8 +926,22 @@
             return False
 
         for key in keys:
-            if key in ["did", "id", "ivl", "lapses", "left", "mod", "nid",
-                       "odid", "odue", "ord", "queue", "reps", "type", "usn"]:
+            if key in [
+                "did",
+                "id",
+                "ivl",
+                "lapses",
+                "left",
+                "mod",
+                "nid",
+                "odid",
+                "odue",
+                "ord",
+                "queue",
+                "reps",
+                "type",
+                "usn",
+            ]:
                 if warning_check is False:
                     return False
 
@@ -962,7 +956,6 @@
             result.append([False, str(e)])
         return result
 
-
     @util.api()
     def getEaseFactors(self, cards):
         easeFactors = []
@@ -977,7 +970,6 @@
 
         return easeFactors
 
-
     @util.api()
     def suspend(self, cards, suspend=True):
         for card in cards:
@@ -997,18 +989,15 @@
 
         return True
 
-
     @util.api()
     def unsuspend(self, cards):
         self.suspend(cards, False)
 
-
     @util.api()
     def suspended(self, card):
         card = self.getCard(card)
         return card.queue == -1
 
-
     @util.api()
     def areSuspended(self, cards):
         suspended = []
@@ -1020,53 +1009,50 @@
 
         return suspended
 
-
     @util.api()
     def areDue(self, cards):
         due = []
         for card in cards:
-            if self.findCards('cid:{} is:new'.format(card)):
+            if self.findCards(f"cid:{card} is:new"):
                 due.append(True)
             else:
-                date, ivl = self.collection().db.all('select id/1000.0, ivl from revlog where cid = ?', card)[-1]
+                date, ivl = self.collection().db.all(
+                    "select id/1000.0, ivl from revlog where cid = ?", card
+                )[-1]
                 if ivl >= -1200:
-                    due.append(bool(self.findCards('cid:{} is:due'.format(card))))
+                    due.append(bool(self.findCards(f"cid:{card} is:due")))
                 else:
                     due.append(date - ivl <= time.time())
 
         return due
 
-
     @util.api()
     def getIntervals(self, cards, complete=False):
         intervals = []
         for card in cards:
-            if self.findCards('cid:{} is:new'.format(card)):
+            if self.findCards(f"cid:{card} is:new"):
                 intervals.append(0)
             else:
-                interval = self.collection().db.list('select ivl from revlog where cid = ?', card)
+                interval = self.collection().db.list("select ivl from revlog where cid = ?", card)
                 if not complete:
                     interval = interval[-1]
                 intervals.append(interval)
 
         return intervals
 
-
-
     @util.api()
     def modelNames(self):
         return self.collection().models.allNames()
 
-
     @util.api()
-    def createModel(self, modelName, inOrderFields, cardTemplates, css = None, isCloze = False):
+    def createModel(self, modelName, inOrderFields, cardTemplates, css=None, isCloze=False):
         # https://github.com/dae/anki/blob/b06b70f7214fb1f2ce33ba06d2b095384b81f874/anki/stdmodels.py
         if len(inOrderFields) == 0:
-            raise Exception('Must provide at least one field for inOrderFields')
+            raise Exception("Must provide at least one field for inOrderFields")
         if len(cardTemplates) == 0:
-            raise Exception('Must provide at least one card for cardTemplates')
+            raise Exception("Must provide at least one card for cardTemplates")
         if modelName in self.collection().models.allNames():
-            raise Exception('Model name already exists')
+            raise Exception("Model name already exists")
 
         collection = self.collection()
         mm = collection.models
@@ -1074,7 +1060,7 @@
         # Generate new Note
         m = mm.new(modelName)
         if isCloze:
-            m['type'] = MODEL_CLOZE
+            m["type"] = MODEL_CLOZE
 
         # Create fields and add them to Note
         for field in inOrderFields:
@@ -1082,207 +1068,195 @@
             mm.addField(m, fm)
 
         # Add shared css to model if exists. Use default otherwise
-        if (css is not None):
-            m['css'] = css
+        if css is not None:
+            m["css"] = css
 
         # Generate new card template(s)
         cardCount = 1
         for card in cardTemplates:
-            cardName = 'Card ' + str(cardCount)
-            if 'Name' in card:
-                cardName = card['Name']
+            cardName = "Card " + str(cardCount)
+            if "Name" in card:
+                cardName = card["Name"]
 
             t = mm.newTemplate(cardName)
             cardCount += 1
-            t['qfmt'] = card['Front']
-            t['afmt'] = card['Back']
+            t["qfmt"] = card["Front"]
+            t["afmt"] = card["Back"]
             mm.addTemplate(m, t)
 
         mm.add(m)
         return m
 
-
     @util.api()
     def modelNamesAndIds(self):
         models = {}
         for model in self.modelNames():
-            models[model] = int(self.collection().models.byName(model)['id'])
+            models[model] = int(self.collection().models.byName(model)["id"])
 
         return models
 
-
     @util.api()
     def modelNameFromId(self, modelId):
         model = self.collection().models.get(modelId)
         if model is None:
-            raise Exception('model was not found: {}'.format(modelId))
+            raise Exception(f"model was not found: {modelId}")
         else:
-            return model['name']
+            return model["name"]
 
-
     @util.api()
     def modelFieldNames(self, modelName):
         model = self.collection().models.byName(modelName)
         if model is None:
-            raise Exception('model was not found: {}'.format(modelName))
+            raise Exception(f"model was not found: {modelName}")
         else:
-            return [field['name'] for field in model['flds']]
+            return [field["name"] for field in model["flds"]]
 
-
     @util.api()
     def modelFieldDescriptions(self, modelName):
         model = self.collection().models.byName(modelName)
         if model is None:
-            raise Exception('model was not found: {}'.format(modelName))
+            raise Exception(f"model was not found: {modelName}")
         else:
             try:
-                return [field['description'] for field in model['flds']]
+                return [field["description"] for field in model["flds"]]
             except KeyError:
                 # older versions of Anki don't have field descriptions
-                return ['' for field in model['flds']]
+                return ["" for field in model["flds"]]
 
-
     @util.api()
     def modelFieldFonts(self, modelName):
         model = self.getModel(modelName)
 
         fonts = {}
-        for field in model['flds']:
-
-            fonts[field['name']] = {
-                'font': field['font'],
-                'size': field['size'],
+        for field in model["flds"]:
+            fonts[field["name"]] = {
+                "font": field["font"],
+                "size": field["size"],
             }
 
         return fonts
 
-
     @util.api()
     def modelFieldsOnTemplates(self, modelName):
         model = self.collection().models.byName(modelName)
         if model is None:
-            raise Exception('model was not found: {}'.format(modelName))
+            raise Exception(f"model was not found: {modelName}")
 
         templates = {}
-        for template in model['tmpls']:
+        for template in model["tmpls"]:
             fields = []
-            for side in ['qfmt', 'afmt']:
+            for side in ["qfmt", "afmt"]:
                 fieldsForSide = []
 
                 # based on _fieldsOnTemplate from aqt/clayout.py
-                matches = re.findall('{{[^#/}]+?}}', template[side])
+                matches = re.findall("{{[^#/}]+?}}", template[side])
                 for match in matches:
                     # remove braces and modifiers
-                    match = re.sub(r'[{}]', '', match)
-                    match = match.split(':')[-1]
+                    match = re.sub(r"[{}]", "", match)
+                    match = match.split(":")[-1]
 
                     # for the answer side, ignore fields present on the question side + the FrontSide field
-                    if match == 'FrontSide' or side == 'afmt' and match in fields[0]:
+                    if match == "FrontSide" or side == "afmt" and match in fields[0]:
                         continue
                     fieldsForSide.append(match)
 
                 fields.append(fieldsForSide)
 
-            templates[template['name']] = fields
+            templates[template["name"]] = fields
 
         return templates
 
-
     @util.api()
     def modelTemplates(self, modelName):
         model = self.collection().models.byName(modelName)
         if model is None:
-            raise Exception('model was not found: {}'.format(modelName))
+            raise Exception(f"model was not found: {modelName}")
 
         templates = {}
-        for template in model['tmpls']:
-            templates[template['name']] = {'Front': template['qfmt'], 'Back': template['afmt']}
+        for template in model["tmpls"]:
+            templates[template["name"]] = {"Front": template["qfmt"], "Back": template["afmt"]}
 
         return templates
 
-
     @util.api()
     def modelStyling(self, modelName):
         model = self.collection().models.byName(modelName)
         if model is None:
-            raise Exception('model was not found: {}'.format(modelName))
+            raise Exception(f"model was not found: {modelName}")
 
-        return {'css': model['css']}
+        return {"css": model["css"]}
 
-
     @util.api()
     def updateModelTemplates(self, model):
         models = self.collection().models
-        ankiModel = models.byName(model['name'])
+        ankiModel = models.byName(model["name"])
         if ankiModel is None:
-            raise Exception('model was not found: {}'.format(model['name']))
+            raise Exception("model was not found: {}".format(model["name"]))
 
-        templates = model['templates']
-        for ankiTemplate in ankiModel['tmpls']:
-            template = templates.get(ankiTemplate['name'])
+        templates = model["templates"]
+        for ankiTemplate in ankiModel["tmpls"]:
+            template = templates.get(ankiTemplate["name"])
             if template:
-                qfmt = template.get('Front')
+                qfmt = template.get("Front")
                 if qfmt:
-                    ankiTemplate['qfmt'] = qfmt
+                    ankiTemplate["qfmt"] = qfmt
 
-                afmt = template.get('Back')
+                afmt = template.get("Back")
                 if afmt:
-                    ankiTemplate['afmt'] = afmt
+                    ankiTemplate["afmt"] = afmt
 
         self.save_model(models, ankiModel)
 
-
     @util.api()
     def updateModelStyling(self, model):
         models = self.collection().models
-        ankiModel = models.byName(model['name'])
+        ankiModel = models.byName(model["name"])
         if ankiModel is None:
-            raise Exception('model was not found: {}'.format(model['name']))
+            raise Exception("model was not found: {}".format(model["name"]))
 
-        ankiModel['css'] = model['css']
+        ankiModel["css"] = model["css"]
 
         self.save_model(models, ankiModel)
 
-
     @util.api()
-    def findAndReplaceInModels(self, modelName, findText, replaceText, front=True, back=True, css=True):
+    def findAndReplaceInModels(
+        self, modelName, findText, replaceText, front=True, back=True, css=True
+    ):
         if not modelName:
             ankiModel = self.collection().models.allNames()
         else:
             model = self.collection().models.byName(modelName)
             if model is None:
-                raise Exception('model was not found: {}'.format(modelName))
+                raise Exception(f"model was not found: {modelName}")
             ankiModel = [modelName]
         updatedModels = 0
         for model in ankiModel:
             model = self.collection().models.byName(model)
             checkForText = False
-            if css and findText in model['css']:
+            if css and findText in model["css"]:
                 checkForText = True
-                model['css'] = model['css'].replace(findText, replaceText)
-            for tmpls in model.get('tmpls'):
-                if front and findText in tmpls['qfmt']:
+                model["css"] = model["css"].replace(findText, replaceText)
+            for tmpls in model.get("tmpls"):
+                if front and findText in tmpls["qfmt"]:
                     checkForText = True
-                    tmpls['qfmt'] = tmpls['qfmt'].replace(findText, replaceText)
-                if back and findText in tmpls['afmt']:
+                    tmpls["qfmt"] = tmpls["qfmt"].replace(findText, replaceText)
+                if back and findText in tmpls["afmt"]:
                     checkForText = True
-                    tmpls['afmt'] = tmpls['afmt'].replace(findText, replaceText)
+                    tmpls["afmt"] = tmpls["afmt"].replace(findText, replaceText)
             self.save_model(self.collection().models, model)
             if checkForText:
                 updatedModels += 1
         return updatedModels
 
-
     @util.api()
     def modelTemplateRename(self, modelName, oldTemplateName, newTemplateName):
         mm = self.collection().models
         model = self.getModel(modelName)
         ankiTemplate = self.getTemplate(model, oldTemplateName)
 
-        ankiTemplate['name'] = newTemplateName
+        ankiTemplate["name"] = newTemplateName
         self.save_model(mm, model)
 
-
     @util.api()
     def modelTemplateReposition(self, modelName, templateName, index):
         mm = self.collection().models
@@ -1292,31 +1266,29 @@
         mm.reposition_template(model, ankiTemplate, index)
         self.save_model(mm, model)
 
-
     @util.api()
     def modelTemplateAdd(self, modelName, template):
         # "Name", "Front", "Back" borrows from `createModel`
         mm = self.collection().models
         model = self.getModel(modelName)
-        name = template['Name']
-        qfmt = template['Front']
-        afmt = template['Back']
+        name = template["Name"]
+        qfmt = template["Front"]
+        afmt = template["Back"]
 
         # updates the template if it already exists
-        for ankiTemplate in model['tmpls']:
-            if ankiTemplate['name'] == name:
-                ankiTemplate['qfmt'] = qfmt
-                ankiTemplate['afmt'] = afmt
+        for ankiTemplate in model["tmpls"]:
+            if ankiTemplate["name"] == name:
+                ankiTemplate["qfmt"] = qfmt
+                ankiTemplate["afmt"] = afmt
                 return
 
         ankiTemplate = mm.new_template(name)
-        ankiTemplate['qfmt'] = qfmt
-        ankiTemplate['afmt'] = afmt
+        ankiTemplate["qfmt"] = qfmt
+        ankiTemplate["afmt"] = afmt
         mm.add_template(model, ankiTemplate)
 
         self.save_model(mm, model)
 
-
     @util.api()
     def modelTemplateRemove(self, modelName, templateName):
         mm = self.collection().models
@@ -1326,7 +1298,6 @@
         mm.remove_template(model, ankiTemplate)
         self.save_model(mm, model)
 
-
     @util.api()
     def modelFieldRename(self, modelName, oldFieldName, newFieldName):
         mm = self.collection().models
@@ -1337,7 +1308,6 @@
 
         self.save_model(mm, model)
 
-
     @util.api()
     def modelFieldReposition(self, modelName, fieldName, index):
         mm = self.collection().models
@@ -1348,7 +1318,6 @@
 
         self.save_model(mm, model)
 
-
     @util.api()
     def modelFieldAdd(self, modelName, fieldName, index=None):
         mm = self.collection().models
@@ -1368,7 +1337,6 @@
 
         self.save_model(mm, model)
 
-
     @util.api()
     def modelFieldRemove(self, modelName, fieldName):
         mm = self.collection().models
@@ -1379,7 +1347,6 @@
 
         self.save_model(mm, model)
 
-
     @util.api()
     def modelFieldSetFont(self, modelName, fieldName, font):
         mm = self.collection().models
@@ -1387,13 +1354,12 @@
         field = self.getField(model, fieldName)
 
         if not isinstance(font, str):
-            raise Exception('font should be a string: {}'.format(font))
+            raise Exception(f"font should be a string: {font}")
 
-        field['font'] = font
+        field["font"] = font
 
         self.save_model(mm, model)
 
-
     @util.api()
     def modelFieldSetFontSize(self, modelName, fieldName, fontSize):
         mm = self.collection().models
@@ -1401,13 +1367,12 @@
         field = self.getField(model, fieldName)
 
         if not isinstance(fontSize, int):
-            raise Exception('fontSize should be an integer: {}'.format(fontSize))
+            raise Exception(f"fontSize should be an integer: {fontSize}")
 
-        field['size'] = fontSize
+        field["size"] = fontSize
 
         self.save_model(mm, model)
 
-
     @util.api()
     def modelFieldSetDescription(self, modelName, fieldName, description):
         mm = self.collection().models
@@ -1415,24 +1380,22 @@
         field = self.getField(model, fieldName)
 
         if not isinstance(description, str):
-            raise Exception('description should be a string: {}'.format(description))
+            raise Exception(f"description should be a string: {description}")
 
-        if 'description' in field: # older versions do not have the 'description' key
-            field['description'] = description
+        if "description" in field:  # older versions do not have the 'description' key
+            field["description"] = description
             self.save_model(mm, model)
             return True
         return False
 
-
     @util.api()
     def deckNameFromId(self, deckId):
         deck = self.collection().decks.get(deckId)
         if deck is None:
-            raise Exception('deck was not found: {}'.format(deckId))
+            raise Exception(f"deck was not found: {deckId}")
 
-        return deck['name']
+        return deck["name"]
 
-
     @util.api()
     def findNotes(self, query=None):
         if query is None:
@@ -1440,7 +1403,6 @@
 
         return list(map(int, self.collection().findNotes(query)))
 
-
     @util.api()
     def findCards(self, query=None):
         if query is None:
@@ -1448,7 +1410,6 @@
 
         return list(map(int, self.collection().findCards(query)))
 
-
     @util.api()
     def cardsInfo(self, cards):
         result = []
@@ -1458,34 +1419,36 @@
                 model = card.model()
                 note = card.note()
                 fields = {}
-                for info in model['flds']:
-                    order = info['ord']
-                    name = info['name']
-                    fields[name] = {'value': note.fields[order], 'order': order}
+                for info in model["flds"]:
+                    order = info["ord"]
+                    name = info["name"]
+                    fields[name] = {"value": note.fields[order], "order": order}
 
-                result.append({
-                    'cardId': card.id,
-                    'fields': fields,
-                    'fieldOrder': card.ord,
-                    'question': util.cardQuestion(card),
-                    'answer': util.cardAnswer(card),
-                    'modelName': model['name'],
-                    'ord': card.ord,
-                    'deckName': self.deckNameFromId(card.did),
-                    'css': model['css'],
-                    'factor': card.factor,
-                    #This factor is 10 times the ease percentage,
-                    # so an ease of 310% would be reported as 3100
-                    'interval': card.ivl,
-                    'note': card.nid,
-                    'type': card.type,
-                    'queue': card.queue,
-                    'due': card.due,
-                    'reps': card.reps,
-                    'lapses': card.lapses,
-                    'left': card.left,
-                    'mod': card.mod,
-                })
+                result.append(
+                    {
+                        "cardId": card.id,
+                        "fields": fields,
+                        "fieldOrder": card.ord,
+                        "question": util.cardQuestion(card),
+                        "answer": util.cardAnswer(card),
+                        "modelName": model["name"],
+                        "ord": card.ord,
+                        "deckName": self.deckNameFromId(card.did),
+                        "css": model["css"],
+                        "factor": card.factor,
+                        # This factor is 10 times the ease percentage,
+                        # so an ease of 310% would be reported as 3100
+                        "interval": card.ivl,
+                        "note": card.nid,
+                        "type": card.type,
+                        "queue": card.queue,
+                        "due": card.due,
+                        "reps": card.reps,
+                        "lapses": card.lapses,
+                        "left": card.left,
+                        "mod": card.mod,
+                    }
+                )
             except NotFoundError:
                 # Anki will give a NotFoundError if the card ID does not exist.
                 # Best behavior is probably to add an 'empty card' to the
@@ -1501,10 +1464,12 @@
         for cid in cards:
             try:
                 card = self.getCard(cid)
-                result.append({
-                    'cardId': card.id,
-                    'mod': card.mod,
-                })
+                result.append(
+                    {
+                        "cardId": card.id,
+                        "mod": card.mod,
+                    }
+                )
             except NotFoundError:
                 # Anki will give a NotFoundError if the card ID does not exist.
                 # Best behavior is probably to add an 'empty card' to the
@@ -1513,31 +1478,31 @@
                 result.append({})
         return result
 
-
     @util.api()
     def forgetCards(self, cards):
         self.startEditing()
         scids = anki.utils.ids2str(cards)
-        self.collection().db.execute('update cards set type=0, queue=0, left=0, ivl=0, due=0, odue=0, factor=0 where id in ' + scids)
+        self.collection().db.execute(
+            "update cards set type=0, queue=0, left=0, ivl=0, due=0, odue=0, factor=0 where id in "
+            + scids
+        )
         self.stopEditing()
 
-
     @util.api()
     def relearnCards(self, cards):
         self.startEditing()
         scids = anki.utils.ids2str(cards)
-        self.collection().db.execute('update cards set type=3, queue=1 where id in ' + scids)
+        self.collection().db.execute("update cards set type=3, queue=1 where id in " + scids)
         self.stopEditing()
 
-
     @util.api()
     def answerCards(self, answers):
         scheduler = self.scheduler()
         success = []
         for answer in answers:
             try:
-                cid = answer['cardId']
-                ease = answer['ease']
+                cid = answer["cardId"]
+                ease = answer["ease"]
                 card = self.getCard(cid)
                 card.start_timer()
                 scheduler.answerCard(card, ease)
@@ -1547,53 +1512,50 @@
 
         return success
 
-
     @util.api()
     def cardReviews(self, deck, startID):
         return self.database().all(
-            'select id, cid, usn, ease, ivl, lastIvl, factor, time, type from revlog ''where id>? and cid in (select id from cards where did=?)',
+            "select id, cid, usn, ease, ivl, lastIvl, factor, time, type from revlog "
+            "where id>? and cid in (select id from cards where did=?)",
             startID,
-            self.decks().id(deck)
+            self.decks().id(deck),
         )
 
-
     @util.api()
     def getReviewsOfCards(self, cards):
-        COLUMNS = ['id', 'usn', 'ease', 'ivl', 'lastIvl', 'factor', 'time', 'type']
-        QUERY = 'select {} from revlog where cid = ?'.format(', '.join(COLUMNS))
+        COLUMNS = ["id", "usn", "ease", "ivl", "lastIvl", "factor", "time", "type"]
+        QUERY = "select {} from revlog where cid = ?".format(", ".join(COLUMNS))
 
         result = {}
         for card in cards:
             query_result = self.database().all(QUERY, card)
-            result[card] = [dict(zip(COLUMNS, row)) for row in query_result]
+            result[card] = [dict(zip(COLUMNS, row, strict=False)) for row in query_result]
 
         return result
 
-
-
     @util.api()
     def reloadCollection(self):
         self.collection().reset()
 
-
     @util.api()
     def getLatestReviewID(self, deck):
-        return self.database().scalar(
-            'select max(id) from revlog where cid in (select id from cards where did=?)',
-            self.decks().id(deck)
-        ) or 0
+        return (
+            self.database().scalar(
+                "select max(id) from revlog where cid in (select id from cards where did=?)",
+                self.decks().id(deck),
+            )
+            or 0
+        )
 
-
     @util.api()
     def insertReviews(self, reviews):
         if len(reviews) > 0:
-            sql = 'insert into revlog(id,cid,usn,ease,ivl,lastIvl,factor,time,type) values '
+            sql = "insert into revlog(id,cid,usn,ease,ivl,lastIvl,factor,time,type) values "
             for row in reviews:
-                sql += '(%s),' % ','.join(map(str, row))
+                sql += "({}),".format(",".join(map(str, row)))
             sql = sql[:-1]
             self.database().execute(sql)
 
-
     @util.api()
     def notesInfo(self, notes):
         result = []
@@ -1603,18 +1565,22 @@
                 model = note.model()
 
                 fields = {}
-                for info in model['flds']:
-                    order = info['ord']
-                    name = info['name']
-                    fields[name] = {'value': note.fields[order], 'order': order}
+                for info in model["flds"]:
+                    order = info["ord"]
+                    name = info["name"]
+                    fields[name] = {"value": note.fields[order], "order": order}
 
-                result.append({
-                    'noteId': note.id,
-                    'tags' : note.tags,
-                    'fields': fields,
-                    'modelName': model['name'],
-                    'cards': self.collection().db.list('select id from cards where nid = ? order by ord', note.id)
-                })
+                result.append(
+                    {
+                        "noteId": note.id,
+                        "tags": note.tags,
+                        "fields": fields,
+                        "modelName": model["name"],
+                        "cards": self.collection().db.list(
+                            "select id from cards where nid = ? order by ord", note.id
+                        ),
+                    }
+                )
             except NotFoundError:
                 # Anki will give a NotFoundError if the note ID does not exist.
                 # Best behavior is probably to add an 'empty card' to the
@@ -1624,7 +1590,6 @@
 
         return result
 
-
     @util.api()
     def deleteNotes(self, notes):
         try:
@@ -1632,7 +1597,6 @@
         finally:
             self.stopEditing()
 
-
     @util.api()
     def removeEmptyNotes(self):
         for model in self.collection().models.all():
@@ -1640,35 +1604,33 @@
                 self.collection().models.rem(model)
         self.window().requireReset()
 
-
     @util.api()
     def cardsToNotes(self, cards):
-        return self.collection().db.list('select distinct nid from cards where id in ' + anki.utils.ids2str(cards))
+        return self.collection().db.list(
+            "select distinct nid from cards where id in " + anki.utils.ids2str(cards)
+        )
 
-
     @util.api()
     def guiBrowse(self, query=None):
-        browser = aqt.dialogs.open('Browser', self.window())
+        browser = aqt.dialogs.open("Browser", self.window())
         browser.activateWindow()
 
         if query is not None:
             browser.form.searchEdit.lineEdit().setText(query)
-            if hasattr(browser, 'onSearch'):
+            if hasattr(browser, "onSearch"):
                 browser.onSearch()
             else:
                 browser.onSearchActivated()
 
         return self.findCards(query)
 
-
     @util.api()
     def guiEditNote(self, note):
         Edit.open_dialog_and_show_note_with_id(note)
 
-
     @util.api()
     def guiSelectedNotes(self):
-        (creator, instance) = aqt.dialogs._dialogs['Browser']
+        (creator, instance) = aqt.dialogs._dialogs["Browser"]
         if instance is None:
             return []
         return instance.selectedNotes()
@@ -1678,16 +1640,16 @@
         if note is not None:
             collection = self.collection()
 
-            deck = collection.decks.byName(note['deckName'])
+            deck = collection.decks.byName(note["deckName"])
             if deck is None:
-                raise Exception('deck was not found: {}'.format(note['deckName']))
+                raise Exception("deck was not found: {}".format(note["deckName"]))
 
-            collection.decks.select(deck['id'])
-            savedMid = deck.pop('mid', None)
+            collection.decks.select(deck["id"])
+            savedMid = deck.pop("mid", None)
 
-            model = collection.models.byName(note['modelName'])
+            model = collection.models.byName(note["modelName"])
             if model is None:
-                raise Exception('model was not found: {}'.format(note['modelName']))
+                raise Exception("model was not found: {}".format(note["modelName"]))
 
             collection.models.setCurrent(model)
             collection.models.update(model)
@@ -1695,32 +1657,32 @@
             ankiNote = anki.notes.Note(collection, model)
 
             # fill out card beforehand, so we can be sure of the note id
-            if 'fields' in note:
-                for name, value in note['fields'].items():
+            if "fields" in note:
+                for name, value in note["fields"].items():
                     if name in ankiNote:
                         ankiNote[name] = value
 
             self.addMediaFromNote(ankiNote, note)
 
-            if 'tags' in note:
-                ankiNote.tags = note['tags']
+            if "tags" in note:
+                ankiNote.tags = note["tags"]
 
             def openNewWindow():
                 nonlocal ankiNote
 
-                addCards = aqt.dialogs.open('AddCards', self.window())
+                addCards = aqt.dialogs.open("AddCards", self.window())
 
                 if savedMid:
-                    deck['mid'] = savedMid
+                    deck["mid"] = savedMid
 
                 addCards.editor.set_note(ankiNote)
 
                 addCards.activateWindow()
 
-                aqt.dialogs.open('AddCards', self.window())
+                aqt.dialogs.open("AddCards", self.window())
                 addCards.setAndFocusNote(addCards.editor.note)
 
-            currentWindow = aqt.dialogs._dialogs['AddCards'][1]
+            currentWindow = aqt.dialogs._dialogs["AddCards"][1]
 
             if currentWindow is not None:
                 currentWindow.closeWithCallback(openNewWindow)
@@ -1730,21 +1692,19 @@
             return ankiNote.id
 
         else:
-            addCards = aqt.dialogs.open('AddCards', self.window())
+            addCards = aqt.dialogs.open("AddCards", self.window())
             addCards.activateWindow()
 
             return addCards.editor.note.id
 
-
     @util.api()
     def guiReviewActive(self):
-        return self.reviewer().card is not None and self.window().state == 'review'
+        return self.reviewer().card is not None and self.window().state == "review"
 
-
     @util.api()
     def guiCurrentCard(self):
         if not self.guiReviewActive():
-            raise Exception('Gui review is not currently active.')
+            raise Exception("Gui review is not currently active.")
 
         reviewer = self.reviewer()
         card = reviewer.card
@@ -1752,27 +1712,28 @@
         note = card.note()
 
         fields = {}
-        for info in model['flds']:
-            order = info['ord']
-            name = info['name']
-            fields[name] = {'value': note.fields[order], 'order': order}
+        for info in model["flds"]:
+            order = info["ord"]
+            name = info["name"]
+            fields[name] = {"value": note.fields[order], "order": order}
 
         buttonList = reviewer._answerButtonList()
         return {
-            'cardId': card.id,
-            'fields': fields,
-            'fieldOrder': card.ord,
-            'question': util.cardQuestion(card),
-            'answer': util.cardAnswer(card),
-            'buttons': [b[0] for b in buttonList],
-            'nextReviews': [reviewer.mw.col.sched.nextIvlStr(reviewer.card, b[0], True) for b in buttonList],
-            'modelName': model['name'],
-            'deckName': self.deckNameFromId(card.did),
-            'css': model['css'],
-            'template': card.template()['name']
+            "cardId": card.id,
+            "fields": fields,
+            "fieldOrder": card.ord,
+            "question": util.cardQuestion(card),
+            "answer": util.cardAnswer(card),
+            "buttons": [b[0] for b in buttonList],
+            "nextReviews": [
+                reviewer.mw.col.sched.nextIvlStr(reviewer.card, b[0], True) for b in buttonList
+            ],
+            "modelName": model["name"],
+            "deckName": self.deckNameFromId(card.did),
+            "css": model["css"],
+            "template": card.template()["name"],
         }
 
-
     @util.api()
     def guiStartCardTimer(self):
         if not self.guiReviewActive():
@@ -1785,7 +1746,6 @@
 
         return False
 
-
     @util.api()
     def guiShowQuestion(self):
         if self.guiReviewActive():
@@ -1794,7 +1754,6 @@
 
         return False
 
-
     @util.api()
     def guiShowAnswer(self):
         if self.guiReviewActive():
@@ -1803,14 +1762,13 @@
 
         return False
 
-
     @util.api()
     def guiAnswerCard(self, ease):
         if not self.guiReviewActive():
             return False
 
         reviewer = self.reviewer()
-        if reviewer.state != 'answer':
+        if reviewer.state != "answer":
             return False
         if ease <= 0 or ease > self.scheduler().answerButtons(reviewer.card):
             return False
@@ -1818,40 +1776,35 @@
         reviewer._answerCard(ease)
         return True
 
-
     @util.api()
     def guiUndo(self):
         self.window().undo()
         return True
 
-
     @util.api()
     def guiDeckOverview(self, name):
         collection = self.collection()
         if collection is not None:
             deck = collection.decks.byName(name)
             if deck is not None:
-                collection.decks.select(deck['id'])
+                collection.decks.select(deck["id"])
                 self.window().onOverview()
                 return True
 
         return False
 
-
     @util.api()
     def guiDeckBrowser(self):
-        self.window().moveToState('deckBrowser')
+        self.window().moveToState("deckBrowser")
 
-
     @util.api()
     def guiDeckReview(self, name):
         if self.guiDeckOverview(name):
-            self.window().moveToState('review')
+            self.window().moveToState("review")
             return True
 
         return False
 
-
     @util.api()
     def guiImportFile(self, path=None):
         """
@@ -1865,12 +1818,12 @@
         if anki_version >= (2, 1, 52):
             from aqt.import_export.importing import import_file, prompt_for_file_then_import
         else:
-            raise Exception('guiImportFile is only supported from Anki version >=2.1.52')
+            raise Exception("guiImportFile is only supported from Anki version >=2.1.52")
 
-        if hasattr(Qt, 'WindowStaysOnTopHint'):
+        if hasattr(Qt, "WindowStaysOnTopHint"):
             # Qt5
             WindowOnTopFlag = Qt.WindowStaysOnTopHint
-        elif hasattr(Qt, 'WindowType') and hasattr(Qt.WindowType, 'WindowStaysOnTopHint'):
+        elif hasattr(Qt, "WindowType") and hasattr(Qt.WindowType, "WindowStaysOnTopHint"):
             # Qt6
             WindowOnTopFlag = Qt.WindowType.WindowStaysOnTopHint
         else:
@@ -1881,11 +1834,11 @@
         if WindowOnTopFlag is not None:
             try:
                 # [Step 1/2] set always on top flag, show window (it stays on top for now)
-                self.window().setWindowFlags(self.window().windowFlags() | WindowOnTopFlag)  
+                self.window().setWindowFlags(self.window().windowFlags() | WindowOnTopFlag)
                 self.window().show()
             finally:
                 # [Step 2/2] clear always on top flag, show window (it doesn't stay on top anymore)
-                self.window().setWindowFlags(self.window().windowFlags() & ~WindowOnTopFlag) 
+                self.window().setWindowFlags(self.window().windowFlags() & ~WindowOnTopFlag)
                 self.window().show()
 
         if path is None:
@@ -1893,20 +1846,17 @@
         else:
             import_file(self.window(), path)
 
-
     @util.api()
     def guiExitAnki(self):
         timer = QTimer()
         timer.timeout.connect(self.window().close)
-        timer.start(1000) # 1s should be enough to allow the response to be sent.
+        timer.start(1000)  # 1s should be enough to allow the response to be sent.
 
-
     @util.api()
     def guiCheckDatabase(self):
         self.window().onCheckDB()
         return True
 
-
     @util.api()
     def addNotes(self, notes):
         results = []
@@ -1918,7 +1868,6 @@
 
         return results
 
-
     @util.api()
     def canAddNotes(self, notes):
         results = []
@@ -1927,7 +1876,6 @@
 
         return results
 
-
     @util.api()
     def exportPackage(self, deck, path, includeSched=False):
         collection = self.collection()
@@ -1935,14 +1883,13 @@
             deck = collection.decks.byName(deck)
             if deck is not None:
                 exporter = AnkiPackageExporter(collection)
-                exporter.did = deck['id']
+                exporter.did = deck["id"]
                 exporter.includeSched = includeSched
                 exporter.exportInto(path)
                 return True
 
         return False
 
-
     @util.api()
     def importPackage(self, path):
         collection = self.collection()
@@ -1960,19 +1907,18 @@
 
         return False
 
-
     @util.api()
     def apiReflect(self, scopes=None, actions=None):
         if not isinstance(scopes, list):
-            raise Exception('scopes has invalid value')
+            raise Exception("scopes has invalid value")
         if not (actions is None or isinstance(actions, list)):
-            raise Exception('actions has invalid value')
+            raise Exception("actions has invalid value")
 
         cls = type(self)
         scopes2 = []
-        result = {'scopes': scopes2}
+        result = {"scopes": scopes2}
 
-        if 'actions' in scopes:
+        if "actions" in scopes:
             if actions is None:
                 actions = dir(cls)
 
@@ -1981,15 +1927,14 @@
                 if not isinstance(methodName, str):
                     pass
                 method = getattr(cls, methodName, None)
-                if method is not None and getattr(method, 'api', False):
+                if method is not None and getattr(method, "api", False):
                     methodNames.append(methodName)
 
-            scopes2.append('actions')
-            result['actions'] = methodNames
+            scopes2.append("actions")
+            result["actions"] = methodNames
 
         return result
 
-
     @util.api()
     def getFSRSStats(self, cards=None):
         if cards is None:
@@ -2016,33 +1961,34 @@
                     try:
                         card = col.get_card(cid)
                     except AttributeError:
-                         item["debug"].append("No get_card or getCard method")
+                        item["debug"].append("No get_card or getCard method")
                 except Exception as e:
-                     item["debug"].append(f"get_card exception: {e}")
+                    item["debug"].append(f"get_card exception: {e}")
                 if not card:
                     item["debug"].append("Card not found")
                     result.append(item)
                     continue
-                
+
                 found_data = False
-                if hasattr(card, 'memory_state'):
+                if hasattr(card, "memory_state"):
                     if card.memory_state:
-                         item["difficulty"] = card.memory_state.difficulty
-                         item["source"] = "memory_state"
-                         found_data = True
-                
+                        item["difficulty"] = card.memory_state.difficulty
+                        item["source"] = "memory_state"
+                        found_data = True
+
                 if not found_data:
-                    if hasattr(card, 'data'):
-                         if card.data:
+                    if hasattr(card, "data"):
+                        if card.data:
                             try:
                                 import json
+
                                 data = json.loads(card.data)
-                                if 'd' in data:
-                                    item["difficulty"] = data['d']
+                                if "d" in data:
+                                    item["difficulty"] = data["d"]
                                     item["source"] = "data_json"
                             except Exception:
                                 pass
-                
+
                 result.append(item)
             except Exception as e:
                 result.append({"cardId": cid, "error": f"Outer loop error: {e}"})
@@ -2055,12 +2001,20 @@
 
 # when run inside Anki, `__name__` would be either numeric,
 # or, if installed via `link.sh`, `AnkiConnectDev`
-if __name__ != "plugin":
-    if platform.system() == "Windows" and anki_version == (2, 1, 50):
-        util.patch_anki_2_1_50_having_null_stdout_on_windows()
+if __name__ != "__main__":
+    try:
+        if platform.system() == "Windows" and anki_version == (2, 1, 50):
+            util.patch_anki_2_1_50_having_null_stdout_on_windows()
 
-    Edit.register_with_anki()
+        Edit.register_with_anki()
 
-    ac = AnkiConnect()
-    ac.initLogging()
-    ac.startWebServer()
+        ac = AnkiConnect()
+        ac.initLogging()
+        ac.startWebServer()
+    except Exception as e:
+        import traceback
+        with open(os.path.join(os.path.dirname(__file__), "startup_error.log"), "w") as f:
+            f.write(f"Add-on failed to start: {e}\n")
+            f.write(traceback.format_exc())
+        # Re-raise so Anki still knows something is wrong, but now we have a log.
+        raise
